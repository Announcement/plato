<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib/server.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/server.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">383</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">61.36</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.09</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

// Load modules

const Events = require(&#039;events&#039;);
const Catbox = require(&#039;catbox&#039;);
const CatboxMemory = require(&#039;catbox-memory&#039;);
const Heavy = require(&#039;heavy&#039;);
const Hoek = require(&#039;hoek&#039;);
const Items = require(&#039;items&#039;);
const Mimos = require(&#039;mimos&#039;);
const Connection = require(&#039;./connection&#039;);
const Defaults = require(&#039;./defaults&#039;);
const Ext = require(&#039;./ext&#039;);
const Methods = require(&#039;./methods&#039;);
const Plugin = require(&#039;./plugin&#039;);
const Promises = require(&#039;./promises&#039;);
const Reply = require(&#039;./reply&#039;);
const Request = require(&#039;./request&#039;);
const Schema = require(&#039;./schema&#039;);


// Declare internals

const internals = {};


exports = module.exports = internals.Server = function (options) {

    Hoek.assert(this instanceof internals.Server, &#039;Server must be instantiated using new&#039;);

    options = Schema.apply(&#039;server&#039;, options || {});

    this._settings = Hoek.applyToDefaultsWithShallow(Defaults.server, options, [&#039;connections.routes.bind&#039;]);
    this._settings.connections = Hoek.applyToDefaultsWithShallow(Defaults.connection, this._settings.connections || {}, [&#039;routes.bind&#039;]);
    this._settings.connections.routes.cors = Hoek.applyToDefaults(Defaults.cors, this._settings.connections.routes.cors);
    this._settings.connections.routes.security = Hoek.applyToDefaults(Defaults.security, this._settings.connections.routes.security);

    this._caches = {};                                                  // Cache clients
    this._handlers = {};                                                // Registered handlers
    this._methods = new Methods(this);                                  // Server methods

    this._events = new Events.EventEmitter();                           // Server-only events
    this._dependencies = [];                                            // Plugin dependencies
    this._registrations = {};                                           // Tracks plugins registered before connection added
    this._heavy = new Heavy(this._settings.load);
    this._mime = new Mimos(this._settings.mime);
    this._replier = new Reply();
    this._requestor = new Request();
    this._decorations = {};
    this._plugins = {};                                                 // Exposed plugin properties by name
    this._app = {};
    this._registring = false;                                           // true while register() is waiting for plugin callbacks
    this._state = &#039;stopped&#039;;                                            // &#039;stopped&#039;, &#039;initializing&#039;, &#039;initialized&#039;, &#039;starting&#039;, &#039;started&#039;, &#039;stopping&#039;, &#039;invalid&#039;

    this._extensionsSeq = 0;                                            // Used to keep absolute order of extensions based on the order added across locations
    this._extensions = {
        onPreStart: new Ext(this),
        onPostStart: new Ext(this),
        onPreStop: new Ext(this),
        onPostStop: new Ext(this)
    };

    if (options.cache) {
        this._createCache(options.cache);
    }

    if (!this._caches._default) {
        this._createCache([{ engine: CatboxMemory }]);                  // Defaults to memory-based
    }

    Plugin.call(this, this, [], &#039;&#039;, null);
};

Hoek.inherits(internals.Server, Plugin);


internals.Server.prototype._createCache = function (options, _callback) {

    Hoek.assert(this._state !== &#039;initializing&#039;, &#039;Cannot provision server cache while server is initializing&#039;);

    options = Schema.apply(&#039;cache&#039;, options);

    const added = [];
    for (let i = 0; i &lt; options.length; ++i) {
        let config = options[i];
        if (typeof config === &#039;function&#039;) {
            config = { engine: config };
        }

        const name = config.name || &#039;_default&#039;;
        Hoek.assert(!this._caches[name], &#039;Cannot configure the same cache more than once: &#039;, name === &#039;_default&#039; ? &#039;default cache&#039; : name);

        let client = null;
        if (typeof config.engine === &#039;object&#039;) {
            client = new Catbox.Client(config.engine);
        }
        else {
            const settings = Hoek.clone(config);
            settings.partition = settings.partition || &#039;hapi-cache&#039;;
            delete settings.name;
            delete settings.engine;
            delete settings.shared;

            client = new Catbox.Client(config.engine, settings);
        }

        this._caches[name] = {
            client: client,
            segments: {},
            shared: config.shared || false
        };

        added.push(client);
    }

    if (!_callback) {
        return;
    }

    // Start cache

    if ([&#039;initialized&#039;, &#039;starting&#039;, &#039;started&#039;].indexOf(this._state) !== -1) {
        const each = (client, next) =&gt; client.start(next);
        return Items.parallel(added, each, _callback);
    }

    return Hoek.nextTick(_callback)();
};


internals.Server.prototype.connection = function (options) {

    const root = this.root;                                   // Explicitly use the root reference (for plugin invocation)

    let settings = Hoek.applyToDefaultsWithShallow(root._settings.connections, options || {}, [&#039;listener&#039;, &#039;routes.bind&#039;]);
    settings.routes.cors = Hoek.applyToDefaults(root._settings.connections.routes.cors || Defaults.cors, settings.routes.cors) || false;
    settings.routes.security = Hoek.applyToDefaults(root._settings.connections.routes.security || Defaults.security, settings.routes.security);

    settings = Schema.apply(&#039;connection&#039;, settings);       // Applies validation changes (type cast)

    const connection = new Connection(root, settings);
    root.connections.push(connection);
    root.addEmitter(connection);
    root._single();

    const registrations = Object.keys(root._registrations);
    for (let i = 0; i &lt; registrations.length; ++i) {
        const name = registrations[i];
        connection.registrations[name] = root._registrations[name];
    }

    return this._clone([connection]);                       // Use this for active realm
};


internals.Server.prototype.start = function (callback) {

    if (!callback) {
        return Promises.wrap(this, this.start);
    }

    Hoek.assert(typeof callback === &#039;function&#039;, &#039;Missing required start callback function&#039;);

    if (this._state === &#039;initialized&#039;) {
        return this._start(callback);
    }

    if (this._state === &#039;started&#039;) {
        Items.serial(this.connections, (connectionItem, next) =&gt; {

            connectionItem._start(next);
        }, callback);

        return;
    }

    if (this._state !== &#039;stopped&#039;) {
        return Hoek.nextTick(callback)(new Error(&#039;Cannot start server while it is in &#039; + this._state + &#039; state&#039;));
    }

    this.initialize((err) =&gt; {

        if (err) {
            return callback(err);
        }

        this._start(callback);
    });
};


internals.Server.prototype.initialize = function (callback) {

    if (!callback) {
        return Promises.wrap(this, this.initialize);
    }

    const nextTickCallback = Hoek.nextTick(callback);
    if (!this.connections.length) {
        return nextTickCallback(new Error(&#039;No connections to start&#039;));
    }

    if (this._registring) {
        return nextTickCallback(new Error(&#039;Cannot start server before plugins finished registration&#039;));
    }

    if (this._state === &#039;initialized&#039;) {
        return nextTickCallback();
    }

    if (this._state !== &#039;stopped&#039;) {
        return nextTickCallback(new Error(&#039;Cannot initialize server while it is in &#039; + this._state + &#039; state&#039;));
    }

    // Assert dependencies

    for (let i = 0; i &lt; this._dependencies.length; ++i) {
        const dependency = this._dependencies[i];
        if (dependency.connections) {
            for (let j = 0; j &lt; dependency.connections.length; ++j) {
                const connection = dependency.connections[j];
                for (let k = 0; k &lt; dependency.deps.length; ++k) {
                    const dep = dependency.deps[k];
                    if (!connection.registrations[dep]) {
                        return nextTickCallback(new Error(&#039;Plugin &#039; + dependency.plugin + &#039; missing dependency &#039; + dep + &#039; in connection: &#039; + connection.info.uri));
                    }
                }
            }
        }
        else {
            for (let j = 0; j &lt; dependency.deps.length; ++j) {
                const dep = dependency.deps[j];
                if (!this._registrations[dep]) {
                    return nextTickCallback(new Error(&#039;Plugin &#039; + dependency.plugin + &#039; missing dependency &#039; + dep));
                }
            }
        }
    }

    this._state = &#039;initializing&#039;;

    // Start cache

    const each = (cache, next) =&gt; {

        this._caches[cache].client.start(next);
    };

    const caches = Object.keys(this._caches);
    Items.parallel(caches, each, (err) =&gt; {

        if (err) {
            this._state = &#039;invalid&#039;;
            return callback(err);
        }

        // After hooks

        this._invoke(&#039;onPreStart&#039;, (err) =&gt; {

            if (err) {
                this._state = &#039;invalid&#039;;
                return callback(err);
            }

            // Load measurements

            this._heavy.start();

            // Listen to connections

            this._state = &#039;initialized&#039;;
            return callback();
        });
    });
};


internals.Server.prototype._start = function (callback) {

    this._state = &#039;starting&#039;;

    const each = (connectionItem, next) =&gt; {

        connectionItem._start(next);
    };

    Items.serial(this.connections, each, (err) =&gt; {

        if (err) {
            this._state = &#039;invalid&#039;;
            return callback(err);
        }

        this._events.emit(&#039;start&#039;);
        this._invoke(&#039;onPostStart&#039;, (err) =&gt; {

            if (err) {
                this._state = &#039;invalid&#039;;
                return callback(err);
            }

            this._state = &#039;started&#039;;
            return callback();
        });
    });
};


internals.Server.prototype.stop = function (/* [options], callback */) {

    const args = arguments.length;
    const lastArg = arguments[args - 1];
    const callback = (!args ? null : (typeof lastArg === &#039;function&#039; ? lastArg : null));
    const options = (!args ? {} : (args === 1 ? (callback ? {} : arguments[0]) : arguments[0]));

    if (!callback) {
        return Promises.wrap(this, this.stop, [options]);
    }

    options.timeout = options.timeout || 5000;                                              // Default timeout to 5 seconds

    if ([&#039;stopped&#039;, &#039;initialized&#039;, &#039;started&#039;, &#039;invalid&#039;].indexOf(this._state) === -1) {
        return Hoek.nextTick(callback)(new Error(&#039;Cannot stop server while in &#039; + this._state + &#039; state&#039;));
    }

    this._state = &#039;stopping&#039;;

    this._invoke(&#039;onPreStop&#039;, (err) =&gt; {

        if (err) {
            this._state = &#039;invalid&#039;;
            return callback(err);
        }

        const each = (connection, next) =&gt; {

            connection._stop(options, next);
        };

        Items.serial(this.connections, each, (err) =&gt; {

            if (err) {
                this._state = &#039;invalid&#039;;
                return callback(err);
            }

            const caches = Object.keys(this._caches);
            for (let i = 0; i &lt; caches.length; ++i) {
                this._caches[caches[i]].client.stop();
            }

            this._events.emit(&#039;stop&#039;);
            this._heavy.stop();
            this._invoke(&#039;onPostStop&#039;, (err) =&gt; {

                if (err) {
                    this._state = &#039;invalid&#039;;
                    return callback(err);
                }

                this._state = &#039;stopped&#039;;
                return callback();
            });
        });
    });
};


internals.Server.prototype._invoke = function (type, next) {

    const exts = this._extensions[type];
    if (!exts.nodes) {
        return next();
    }

    Items.serial(exts.nodes, (ext, nextExt) =&gt; {

        const bind = (ext.bind || ext.plugin.realm.settings.bind);
        ext.func.call(bind, ext.plugin._select(), nextExt);
    }, next);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
